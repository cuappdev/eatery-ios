"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const ast_1 = require("./ast");
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
    if (graphql_1.isNamedType(oldType)) {
        return ((graphql_1.isNamedType(newType) && oldType.name === newType.name) ||
            (graphql_1.isNonNullType(newType) &&
                isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)));
    }
    else if (graphql_1.isListType(oldType)) {
        return ((graphql_1.isListType(newType) &&
            isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)) ||
            (graphql_1.isNonNullType(newType) &&
                isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)));
    }
    else if (graphql_1.isNonNullType(oldType)) {
        return (graphql_1.isNonNullType(newType) &&
            isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType));
    }
    return false;
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
    if (graphql_1.isNamedType(oldType)) {
        return graphql_1.isNamedType(newType) && oldType.name === newType.name;
    }
    else if (graphql_1.isListType(oldType)) {
        return (graphql_1.isListType(newType) &&
            isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType));
    }
    else if (graphql_1.isNonNullType(oldType)) {
        return ((graphql_1.isNonNullType(newType) &&
            isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)) ||
            (!graphql_1.isNonNullType(newType) &&
                isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)));
    }
    return false;
}
function typeKindName(type) {
    if (graphql_1.isScalarType(type)) {
        return "a Scalar type";
    }
    if (graphql_1.isObjectType(type)) {
        return "an Object type";
    }
    if (graphql_1.isInterfaceType(type)) {
        return "an Interface type";
    }
    if (graphql_1.isUnionType(type)) {
        return "a Union type";
    }
    if (graphql_1.isEnumType(type)) {
        return "an Enum type";
    }
    if (graphql_1.isInputObjectType(type)) {
        return "an Input type";
    }
    throw new TypeError("Unknown type " + type.constructor.name);
}
const m = (text) => "`" + text + "`";
const diffTypesLeft = (type, next, changes) => {
    if (!next[type.name]) {
        const change = {
            change: ast_1.ChangeType.WARNING,
            code: "TYPE_REMOVED",
            description: `${m(type)} removed`,
            type: type.astNode
        };
        changes.push(change);
        if (!type.astNode)
            return;
        throw true;
    }
    const oldType = type;
    const newType = next[type.name];
    if (graphql_1.isObjectType(oldType) && graphql_1.isObjectType(newType)) {
        const oldInterfaces = oldType.getInterfaces();
        const newInterfaces = newType.getInterfaces();
        oldInterfaces.forEach(oldInterface => {
            if (!newInterfaces.some(int => int.name === oldInterface.name)) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "INTERFACE_REMOVED_FROM_OBJECT",
                    description: `${m(type.name)} no longer implements interface ${m(oldInterface.name)}`,
                    type: newType.astNode
                };
                changes.push(change);
            }
        });
    }
    if (graphql_1.isUnionType(oldType) && graphql_1.isUnionType(newType)) {
        const typeNamesInNewUnion = Object.create(null);
        newType.getTypes().forEach(type => {
            typeNamesInNewUnion[type.name] = true;
        });
        oldType.getTypes().forEach(type => {
            if (!typeNamesInNewUnion[type.name]) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "TYPE_REMOVED_FROM_UNION",
                    description: `${m(type.name)} was removed from union type ${m(oldType.name)}.`,
                    type: newType.astNode
                };
                changes.push(change);
            }
        });
    }
};
const diffFieldsLeft = (oldType, newType, changes) => {
    if (graphql_1.isEnumType(oldType) && graphql_1.isEnumType(newType)) {
        const valuesInNewEnum = Object.create(null);
        newType.getValues().forEach(value => {
            valuesInNewEnum[value.name] = true;
        });
        oldType.getValues().forEach(value => {
            if (!valuesInNewEnum[value.name]) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "ENUM_VALUE_REMOVED",
                    description: `${m(value.name)} was removed from enum type ${m(newType)}.`,
                    type: newType.astNode,
                    field: value.astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.values))
                    return;
                const valueDef = t.values.find(({ name }) => name.value === value.name);
                if (!valueDef) {
                    t.values.push(Object.assign({}, value.astNode, { change }));
                }
                else {
                    valueDef.change = change;
                }
            }
        });
    }
    if (graphql_1.isObjectType(oldType) ||
        (graphql_1.isInterfaceType(oldType) &&
            (graphql_1.isObjectType(newType) || graphql_1.isInterfaceType(newType)))) {
        const oldTypeFieldsDef = oldType.getFields();
        const newTypeFieldsDef = newType.getFields();
        Object.keys(oldTypeFieldsDef).forEach(fieldName => {
            if (!(fieldName in newTypeFieldsDef)) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "FIELD_REMOVED",
                    description: `${m(`${newType}.${fieldName}`)} was removed`,
                    type: newType.astNode,
                    field: oldTypeFieldsDef[fieldName].astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (!fieldDef) {
                    t.fields.push(Object.assign({}, oldTypeFieldsDef[fieldName].astNode, { change }));
                }
                else {
                    fieldDef.change = change;
                }
                return;
            }
            const oldFieldType = oldTypeFieldsDef[fieldName].type;
            const newFieldType = newTypeFieldsDef[fieldName].type;
            const isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);
            if (!isSafe) {
                const oldFieldTypeString = graphql_1.isNamedType(oldFieldType)
                    ? oldFieldType.name
                    : oldFieldType.toString();
                const newFieldTypeString = graphql_1.isNamedType(newFieldType)
                    ? newFieldType.name
                    : newFieldType.toString();
                const change = {
                    code: "FIELD_CHANGED_KIND",
                    description: `${m(`${newType.name}.${fieldName}`)} changed type from ` +
                        `${m(oldFieldTypeString)} to ${m(newFieldTypeString)}.`,
                    change: ast_1.ChangeType.WARNING,
                    type: newType.astNode,
                    field: newTypeFieldsDef[fieldName].astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (!fieldDef) {
                    t.fields.push(Object.assign({}, oldTypeFieldsDef[fieldName].astNode, { change }));
                }
                else {
                    fieldDef.change = change;
                }
            }
            oldTypeFieldsDef[fieldName].args.forEach(oldArgDef => {
                const newArgs = newTypeFieldsDef[fieldName].args;
                const newArgDef = newArgs.find(arg => arg.name === oldArgDef.name);
                if (!newArgDef) {
                    const change = {
                        change: ast_1.ChangeType.WARNING,
                        code: "ARG_REMOVED",
                        description: `${m(`${oldType}.${fieldName}`)} arg ${m(oldArgDef.name)} was removed`,
                        type: newType.astNode,
                        field: newTypeFieldsDef[fieldName].astNode,
                        arg: oldArgDef.astNode
                    };
                    changes.push(change);
                    const t = change.type;
                    if (!t || !Array.isArray(t.fields))
                        return;
                    const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                    if (!fieldDef) {
                        t.fields.push(Object.assign({}, oldTypeFieldsDef[fieldName].astNode, { change }));
                    }
                    else {
                        fieldDef.change = change;
                    }
                }
                else {
                    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
                    let change;
                    if (!isSafe) {
                        change = {
                            code: "ARG_CHANGED_KIND",
                            change: ast_1.ChangeType.WARNING,
                            description: `${m(`${oldType.name}.${fieldName}`)} arg ` +
                                `${m(oldArgDef.name)} has changed type from ` +
                                `${m(oldArgDef.type)} to ${m(newArgDef.type)}`,
                            type: newType.astNode,
                            field: newTypeFieldsDef[fieldName].astNode,
                            arg: oldArgDef.astNode
                        };
                    }
                    else if (oldArgDef.defaultValue !== undefined &&
                        oldArgDef.defaultValue !== newArgDef.defaultValue) {
                        change = {
                            code: "ARG_DEFAULT_VALUE_CHANGE",
                            change: ast_1.ChangeType.WARNING,
                            description: `${m(`${oldType.name}.${fieldName}`)} arg ` +
                                `${m(oldArgDef.name)} has changed defaultValue`,
                            type: newType.astNode,
                            field: newTypeFieldsDef[fieldName].astNode,
                            arg: oldArgDef.astNode
                        };
                    }
                    if (!change)
                        return;
                    changes.push(change);
                    const t = change.type;
                    if (!t || !Array.isArray(t.fields))
                        return;
                    const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                    fieldDef.change = change;
                }
            });
        });
    }
    if (graphql_1.isInputObjectType(oldType) && graphql_1.isInputObjectType(newType)) {
        const oldTypeFieldsDef = oldType.getFields();
        const newTypeFieldsDef = newType.getFields();
        Object.keys(oldTypeFieldsDef).forEach(fieldName => {
            if (!(fieldName in newTypeFieldsDef)) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "INPUT_FIELD_REMOVED",
                    description: `${m(`${newType}.${fieldName}`)} was removed`,
                    type: newType.astNode,
                    field: oldTypeFieldsDef[fieldName].astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (!fieldDef) {
                    t.fields.push(Object.assign({}, oldTypeFieldsDef[fieldName].astNode, { change }));
                }
                else {
                    fieldDef.change = change;
                }
            }
            if (!newTypeFieldsDef[fieldName])
                return;
            const oldFieldType = oldTypeFieldsDef[fieldName].type;
            const newFieldType = newTypeFieldsDef[fieldName].type;
            const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);
            if (!isSafe) {
                const oldFieldTypeString = graphql_1.isNamedType(oldFieldType)
                    ? oldFieldType.name
                    : oldFieldType.toString();
                const newFieldTypeString = graphql_1.isNamedType(newFieldType)
                    ? newFieldType.name
                    : newFieldType.toString();
                const change = {
                    code: "FIELD_CHANGED_KIND",
                    description: `${m(`${newType.name}.${fieldName}`)} changed type from ` +
                        `${m(oldFieldTypeString)} to ${m(newFieldTypeString)}.`,
                    change: ast_1.ChangeType.WARNING,
                    type: newType.astNode,
                    field: newTypeFieldsDef[fieldName].astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (!fieldDef) {
                    t.fields.push(Object.assign({}, oldTypeFieldsDef[fieldName].astNode, { change }));
                }
                else {
                    fieldDef.change = change;
                }
            }
        });
    }
};
const diffTypesRight = (type, current, changes) => {
    const oldType = current[type.name];
    if (!oldType) {
        const change = {
            change: ast_1.ChangeType.NOTICE,
            code: "TYPE_ADDED",
            description: `${m(type)} added`,
            type: type.astNode
        };
        changes.push(change);
        throw true;
    }
    const newType = type;
    if (oldType.constructor !== newType.constructor) {
        const change = {
            change: ast_1.ChangeType.WARNING,
            code: "TYPE_CHANGED_KIND",
            description: `${m(type.name)} changed from ` +
                `${typeKindName(oldType)} to ${typeKindName(newType)}.`,
            type: newType.astNode
        };
        changes.push(change);
    }
    if (graphql_1.isObjectType(oldType) && graphql_1.isObjectType(newType)) {
        const oldInterfaces = oldType.getInterfaces();
        const newInterfaces = newType.getInterfaces();
        newInterfaces.forEach(newInterface => {
            if (!oldInterfaces.some(int => int.name === newInterface.name)) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "INTERFACE_ADDED_TO_OBJECT",
                    description: `${m(newInterface.name)} was added to type ${m(newType.name)}`,
                    type: newType.astNode
                };
                changes.push(change);
            }
        });
    }
    if (graphql_1.isUnionType(oldType) && graphql_1.isUnionType(newType)) {
        const typeNamesInOldUnion = Object.create(null);
        oldType.getTypes().forEach(type => {
            typeNamesInOldUnion[type.name] = true;
        });
        newType.getTypes().forEach(type => {
            if (!typeNamesInOldUnion[type.name]) {
                const change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "TYPE_ADDED_TO_UNION",
                    description: `${m(type.name)} was added to union type ${m(oldType.name)}.`,
                    type: newType.astNode
                };
                changes.push(change);
            }
        });
    }
};
const diffFieldsRight = (oldType, newType, changes) => {
    if (graphql_1.isEnumType(oldType) && graphql_1.isEnumType(newType)) {
        const valuesInOldEnum = Object.create(null);
        oldType.getValues().forEach(value => {
            valuesInOldEnum[value.name] = true;
        });
        newType.getValues().forEach(value => {
            if (!valuesInOldEnum[value.name]) {
                const change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "ENUM_VALUE_ADDED",
                    description: `${m(value.name)} was added to enum type ${m(newType)}.`,
                    type: newType.astNode,
                    field: value.astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.values))
                    return;
                const valueDef = t.values.find(({ name }) => name.value === value.name);
                if (valueDef)
                    valueDef.change = change;
            }
            let change;
            const oldValue = oldType.getValue(value.name);
            if (!oldValue)
                return;
            if (!oldValue.isDeprecated && value.isDeprecated) {
                change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "ENUM_DEPRECATED",
                    description: `${m(`${newType}.${value.name}`)} was deprecated`,
                    type: newType.astNode,
                    field: oldValue.astNode
                };
            }
            else if (oldValue.isDeprecated && !value.isDeprecated) {
                change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "ENUM_DEPRECATION_REMOVED",
                    description: `${m(`${newType}.${value.name}`)} is no longer deprecated`,
                    type: newType.astNode,
                    field: oldValue.astNode
                };
            }
            else if (oldValue.isDeprecated &&
                value.isDeprecated &&
                oldValue.deprecationReason !== value.deprecationReason) {
                change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "ENUM_DEPRECATED_REASON_CHANGE",
                    description: `${m(`${newType}.${value.name}`)} deprecation reason changed`,
                    type: newType.astNode,
                    field: oldValue.astNode
                };
            }
            if (!change)
                return;
            changes.push(change);
            const t = change.type;
            if (!t || !Array.isArray(t.values))
                return;
            const valueDef = t.values.find(({ name }) => name.value === value.name);
            if (valueDef)
                valueDef.change = change;
        });
    }
    if (graphql_1.isObjectType(oldType) ||
        (graphql_1.isInterfaceType(oldType) &&
            (graphql_1.isObjectType(newType) || graphql_1.isInterfaceType(newType)))) {
        const oldTypeFieldsDef = oldType.getFields();
        const newTypeFieldsDef = newType.getFields();
        Object.keys(newTypeFieldsDef).forEach(fieldName => {
            if (!(fieldName in oldTypeFieldsDef)) {
                const change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "FIELD_ADDED",
                    description: `${m(`${newType}.${fieldName}`)} was added`,
                    type: newType.astNode,
                    field: newTypeFieldsDef[fieldName].astNode
                };
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (fieldDef)
                    fieldDef.change = change;
                return;
            }
            let change;
            if (!oldTypeFieldsDef[fieldName].isDeprecated &&
                newTypeFieldsDef[fieldName].isDeprecated) {
                change = {
                    change: ast_1.ChangeType.WARNING,
                    code: "FIELD_DEPRECATED",
                    description: `${m(`${newType}.${fieldName}`)} was deprecated`,
                    type: newType.astNode,
                    field: newTypeFieldsDef[fieldName].astNode
                };
            }
            else if (oldTypeFieldsDef[fieldName].isDeprecated &&
                !newTypeFieldsDef[fieldName].isDeprecated) {
                change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "FIELD_DEPRECATION_REMOVED",
                    description: `${m(`${newType}.${fieldName}`)} is no longer deprecated`,
                    type: newType.astNode,
                    field: newTypeFieldsDef[fieldName].astNode
                };
            }
            else if (oldTypeFieldsDef[fieldName].isDeprecated &&
                newTypeFieldsDef[fieldName].isDeprecated &&
                oldTypeFieldsDef[fieldName].deprecationReason !==
                    newTypeFieldsDef[fieldName].deprecationReason) {
                change = {
                    change: ast_1.ChangeType.NOTICE,
                    code: "FIELD_DEPRECATED_REASON_CHANGE",
                    description: `${m(`${newType}.${fieldName}`)} deprecation reason changed`,
                    type: newType.astNode
                };
            }
            if (change) {
                changes.push(change);
                const t = change.type;
                if (!t || !Array.isArray(t.fields))
                    return;
                const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                if (fieldDef)
                    fieldDef.change = change;
            }
            newTypeFieldsDef[fieldName].args.forEach(newArgDef => {
                const oldArgs = oldTypeFieldsDef[fieldName].args;
                const oldArgDef = oldArgs.find(arg => arg.name === newArgDef.name);
                if (!oldArgDef) {
                    const change = {
                        change: ast_1.ChangeType.NOTICE,
                        code: "ARG_ADDED",
                        description: `${m(`${oldType}.${fieldName}`)} arg ${m(newArgDef.name)} was added`,
                        type: newType.astNode,
                        field: newTypeFieldsDef[fieldName].astNode,
                        arg: newArgDef.astNode
                    };
                    changes.push(change);
                    const t = change.type;
                    if (!t || !Array.isArray(t.fields))
                        return;
                    const fieldDef = t.fields.find(({ name }) => name.value === fieldName);
                    fieldDef.change = change;
                }
            });
        });
    }
    if (graphql_1.isInputObjectType(oldType) && graphql_1.isInputObjectType(newType)) {
        const oldTypeFieldsDef = oldType.getFields();
        const newTypeFieldsDef = newType.getFields();
        Object.keys(newTypeFieldsDef).forEach(fieldName => {
            if (!(fieldName in oldTypeFieldsDef)) {
                let change;
                if (graphql_1.isNonNullType(newTypeFieldsDef[fieldName].type)) {
                    change = {
                        change: ast_1.ChangeType.WARNING,
                        code: "NON_NULL_INPUT_FIELD_ADDED",
                        description: `A non-null field ${m(fieldName)} on input type ${m(newType.name)} was added.`,
                        type: newType.astNode
                    };
                }
                else {
                    change = {
                        change: ast_1.ChangeType.NOTICE,
                        code: "NULLABLE_INPUT_FIELD_ADDED",
                        description: `A nullable field ${m(fieldName)} on input type ${m(newType.name)} was added.`,
                        type: newType.astNode,
                        field: newTypeFieldsDef[fieldName].astNode
                    };
                }
                changes.push(change);
                const t = change.type;
                const fieldDef = Boolean(t && Array.isArray(t.fields))
                    ? t.fields.find(({ name }) => name.value === fieldName)
                    : undefined;
                if (fieldDef)
                    fieldDef.change = change;
                return;
            }
        });
    }
};
const diffLeft = (current, next, changes) => {
    Object.keys(current).forEach(typeName => {
        const oldType = current[typeName];
        const newType = next[typeName];
        try {
            diffTypesLeft(oldType, next, changes);
            diffFieldsLeft(current[typeName], newType, changes);
        }
        catch (r) {
            if (r instanceof Error)
                throw r;
        }
    });
};
const diffRight = (next, current, changes) => {
    Object.keys(next).forEach(typeName => {
        const newType = next[typeName];
        if (!newType.astNode)
            return;
        try {
            diffTypesRight(newType, current, changes);
            diffFieldsRight(current[typeName], newType, changes);
        }
        catch (r) {
            if (r instanceof Error)
                throw r;
        }
    });
};
exports.diffSchemas = (current, next) => {
    const changes = [];
    diffRight(next, current, changes);
    diffLeft(current, next, changes);
    return changes.sort(sorter);
};
const sorter = (a, b) => {
    if (a.change === b.change)
        return 0;
    if (b.change === ast_1.ChangeType.FAILURE)
        return 1;
    if (b.change === ast_1.ChangeType.WARNING)
        return 1;
    if (b.change === ast_1.ChangeType.NOTICE)
        return -1;
    return 0;
};
//# sourceMappingURL=diff.js.map